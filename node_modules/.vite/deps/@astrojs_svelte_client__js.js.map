{
  "version": 3,
  "sources": ["../../.pnpm/@astrojs+svelte@7.0.3_@types+node@22.10.1_astro@5.1.6_@types+node@22.10.1_jiti@1.21.6_lightni_2gom3jvtvg2ool4ckvq3muwpha/node_modules/@astrojs/svelte/client.svelte.js"],
  "sourcesContent": ["import { createRawSnippet, hydrate, mount, unmount } from 'svelte';\n\n/** @type {WrakMap<any, ReturnType<typeof createComponent>} */\nconst existingApplications = new WeakMap();\n\nexport default (element) => {\n\treturn async (Component, props, slotted, { client }) => {\n\t\tif (!element.hasAttribute('ssr')) return;\n\n\t\tlet children = undefined;\n\t\tlet _$$slots = undefined;\n\t\tlet renderFns = {};\n\n\t\tfor (const [key, value] of Object.entries(slotted)) {\n\t\t\t// Legacy slot support\n\t\t\t_$$slots ??= {};\n\t\t\tif (key === 'default') {\n\t\t\t\t_$$slots.default = true;\n\t\t\t\tchildren = createRawSnippet(() => ({\n\t\t\t\t\trender: () => `<astro-slot>${value}</astro-slot>`,\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\t_$$slots[key] = createRawSnippet(() => ({\n\t\t\t\t\trender: () => `<astro-slot name=\"${key}\">${value}</astro-slot>`,\n\t\t\t\t}));\n\t\t\t}\n\t\t\t// @render support for Svelte ^5.0\n\t\t\tif (key === 'default') {\n\t\t\t\trenderFns.children = createRawSnippet(() => ({\n\t\t\t\t\trender: () => `<astro-slot>${value}</astro-slot>`,\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\trenderFns[key] = createRawSnippet(() => ({\n\t\t\t\t\trender: () => `<astro-slot name=\"${key}\">${value}</astro-slot>`,\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\n\t\tconst resolvedProps = {\n\t\t\t...props,\n\t\t\tchildren,\n\t\t\t$$slots: _$$slots,\n\t\t\t...renderFns,\n\t\t};\n\t\tif (existingApplications.has(element)) {\n\t\t\texistingApplications.get(element).setProps(resolvedProps);\n\t\t} else {\n\t\t\tconst component = createComponent(Component, element, resolvedProps, client !== 'only');\n\t\t\texistingApplications.set(element, component);\n\t\t\telement.addEventListener('astro:unmount', () => component.destroy(), { once: true });\n\t\t}\n\t};\n};\n\n/**\n * @param {any} Component\n * @param {HTMLElement} target\n * @param {Record<string, any>} props\n * @param {boolean} shouldHydrate\n */\nfunction createComponent(Component, target, props, shouldHydrate) {\n\tlet propsState = $state(props);\n\tconst bootstrap = shouldHydrate ? hydrate : mount;\n\tconst component = bootstrap(Component, { target, props: propsState });\n\treturn {\n\t\tsetProps(newProps) {\n\t\t\tObject.assign(propsState, newProps);\n\t\t\t// Remove props in `propsState` but not in `newProps`\n\t\t\tfor (const key in propsState) {\n\t\t\t\tif (!(key in newProps)) {\n\t\t\t\t\tdelete propsState[key];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tdestroy() {\n\t\t\tunmount(component);\n\t\t},\n\t};\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;IAGM,uBAAoB,oBAAO,QAAO;6BAExB,YAAO;gBACR,WAAW,OAAO,SAAO,EAAI,OAAM,MAAA;SAC3C,QAAQ,aAAa,KAAK,EAAA;QAE3B,WAAW;QACX,WAAW;QACX,YAAS,CAAA;gBAED,KAAK,KAAK,KAAK,OAAO,QAAQ,OAAO,GAAA;AAEhD,8BAAQ,CAAA;wBACJ,KAAQ,SAAS,GAAA;AACpB,iBAAS,UAAU;AACnB,mBAAW,iBAAgB,OAAA;UAC1B,QAAM,MAAA,eAAuB,KAAK;;;AAGnC,iBAAS,GAAG,IAAI,iBAAgB,OAAA;UAC/B,QAAM,MAAA,qBAA6B,GAAG,KAAK,KAAK;;;wBAI9C,KAAQ,SAAS,GAAA;AACpB,kBAAU,WAAW,iBAAgB,OAAA;UACpC,QAAM,MAAA,eAAuB,KAAK;;;AAGnC,kBAAU,GAAG,IAAI,iBAAgB,OAAA;UAChC,QAAM,MAAA,qBAA6B,GAAG,KAAK,KAAK;;;;UAK7C,gBAAa;SACf;MACH;MACA,SAAS;SACN;;QAEA,qBAAqB,IAAI,OAAO,GAAA;AACnC,2BAAqB,IAAI,OAAO,EAAE,SAAS,aAAa;;YAElD,YAAY,gBAAgB,WAAW,SAAS,eAAa,cAAE,QAAW,QAAM,KAAA,CAAA;AACtF,2BAAqB,IAAI,SAAS,SAAS;AAC3C,cAAQ,iBAAiB,iBAAe,MAAQ,UAAU,QAAO,GAAA,EAAM,MAAM,KAAI,CAAA;;;;SAW3E,gBAAgB,WAAW,QAAQ,OAAO,eAAa;MAC3D,aAAU,MAAU,KAAK;QACvB,YAAY,gBAAgB,UAAU;QACtC,YAAY,UAAU,WAAS,EAAI,QAAQ,OAAO,WAAU,CAAA;;IAEjE,SAAS,UAAQ;AAChB,aAAO,OAAO,YAAY,QAAQ;iBAEvB,OAAO,YAAU;cACrB,OAAO,WAAQ;iBACb,WAAW,GAAG;;;;IAIxB,UAAO;AACN,cAAQ,SAAS;;;;",
  "names": []
}
